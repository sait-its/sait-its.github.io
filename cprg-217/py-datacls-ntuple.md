### What is a Data Class

- In Python, a data class is a class that is designed to only hold data values.
- They aren't different from regular classes, but they usually don't have any other methods.
- They are typically used to store information that will be passed between different parts of a program or a system.
- `dataclasses` module was added in Python version 3.7.

---

### Use a Regular Class

- When creating classes to work only as data containers, writing the `__init__` method repeatedly can generate a great amount of work and potential errors.

```python
# Use regular class to store data about a student
class NormalStudent():
    def __init__(self, name, age, school):
        self.name = name
        self.age = age
        self.school = school

print(NormalStudent("Mario", 20, "SADT"))
```

---

### Use a Data Class

- Import `dataclass` to use it as a decorator in the class we're creating. No longer need to write the `__init__` function, only specify the attributes of the class and their types.

```python
from dataclasses import dataclass

@dataclass
class Student():
    # __init__ automatically generated by @dataclass
    name: str   # field
    age: int    # field
    school: str # field

print(Student("Mario", 20, "SADT"))
```

---

###  `@dataclass`  Fields

- A `field` is defined as a class variable that has a [type annotation](https://docs.python.org/3/glossary.html#term-variable-annotation).
- The order of the fields in all of the generated methods is the order in which they appear in the class definition.
- You can customize a field's behavior using the `field()` function, which allows you to set default values, exclude fields from certain methods, and specify factory functions for defaults.

---

### Spot the Difference

- `dataclasses` module provides a decorator and functions for automatically adding generated [special methods](https://docs.python.org/3/glossary.html#term-special-method) such as [`__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__) and [`__repr__()`](https://docs.python.org/3/reference/datamodel.html#object.__repr__) to user-defined classes.

```python
print(NormalStudent("Mario", 20, "SADT"))
# <__main__.NormalStudent object at 0x7ad98824db80>

print(Student("Mario", 20, "SADT")
# Student(name='Mario', age=20, school='SADT')
```

---

### `.__repr__()` and `.__str__()`

- A string representation is a string that shows information about the object.
- Both return string representations of the object.
- `.__repr__()` provides the **official string representation** of an object for programmers.
- `.__str__()` provides the **informal string representation** of an object for users.

---

### `.__eq__()` Magic Method

- [`__eq__()`](https://docs.python.org/3/reference/datamodel.html#object.__eq__) method will be generated by default.
- This method compares the class as if it were a tuple of its fields, in order.

```python
norm_student_1 = NormalStudent("Mario", 20, "SADT")
norm_student_2 = NormalStudent("Mario", 20, "SADT")
print(norm_student_1 == norm_student_2)   # False

student_1 = Student("Mario", 20, "SADT")
student_2 = Student("Mario", 20, "SADT")
student_3 = Student("Luigi", 19, "SADT")
print(student_1 == student_2)             # True
print(student_2 == student_3)             # False
```

---

#### Two Forms of `@dataclass` Decorator

- The simple form where `@dataclass` is specified without any parentheses and parameters.
- You can also give parameters to the `@dataclass()` decorator in parentheses.
- Default parameters of `init`, `repr` and `eq` are `True`, which automatically add `.__init__()`, `.__repr__()`, and `.__eq__()` methods to the class.

---

#### Two Forms of `@dataclass` Decorator

- `order`: Add ordering methods? (Default is `False`.)
- `unsafe_hash`: Force the addition of a `.__hash__()` method? (Default is `False`.)
- `frozen`: If `True`, assigning to fields raise an exception. (Default is `False`.)

---

### Object Comparison of Regular Class

- Without [`__lt__()`](https://docs.python.org/3/reference/datamodel.html#object.__lt__), [`__le__()`](https://docs.python.org/3/reference/datamodel.html#object.__le__), [`__gt__()`](https://docs.python.org/3/reference/datamodel.html#object.__gt__), and [`__ge__()`](https://docs.python.org/3/reference/datamodel.html#object.__ge__) magic methods, comparing two instances of the same class with result in `TypeError`.

```python
norm_student_1 = NormalStudent("Mario", 20, "SADT")
norm_student_2 = NormalStudent("Mario", 20, "SADT")
print(norm_student_1 > norm_student_2)

# TypeError: '>' not supported between instances ...
```

---

### `order` Parameter of `@dataclass`

- `order`: If True (the default is `False`), [`__lt__()`](https://docs.python.org/3/reference/datamodel.html#object.__lt__), [`__le__()`](https://docs.python.org/3/reference/datamodel.html#object.__le__), [`__gt__()`](https://docs.python.org/3/reference/datamodel.html#object.__gt__), and [`__ge__()`](https://docs.python.org/3/reference/datamodel.html#object.__ge__) methods will be generated. These compare the class as if it were a tuple of its fields, in order.

```python
from dataclasses import dataclass

@dataclass(order=True)
class Student():
    name: str
    age: int
    school: str

print(Student("John", 30, "SC") > Student("Jane", 30, "SC"))
```

---

### `frozen` Parameter of `@dataclass`

- If true (the default is `False`), assigning to fields will generate an exception. This emulates read-only frozen instances.

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class Student():
    name: str
    age: int
    school: str

student = Student("Bowser", 100, "SADT")
student.age = 101  # FrozenInstanceError
```

---

### `dataclasses.field` Function

- For common and simple use cases, no other functionality is required.
- For some dataclass features that require additional per-field information, you can replace the default field value with a call to the provided `field()` function.
- `field()` function's *default_factory* parameter can be used to specify fields with mutable default values.

---

### `dataclasses.field` Function

```python
from dataclasses import dataclass, field
import random

@dataclass()
class Student():
    name: str
    age: int = field(repr=False) # Don't print the age
    school: str
    height: int = field(default_factory=
                        lambda: random.randint(100, 200))

print(Student("Bowser", 100, "SADT"))
# Student(name='Bowser', school='SADT', height=RANDOM_VALUE)
```

---

### `dataclasses.field` Function

- Practical use of `field` and `default_factory`

```python
from dataclasses import dataclass, field
from datetime import datetime

@dataclass
class APIResponse:
    status: int
    message: str
    timestamp: datetime = field(default_factory=datetime.now)

print(APIResponse(404, "Resource not found."))
# APIResponse(status=404, message='Resource not found.',
# timestamp=datetime.datetime(2025, 6, 17, 0, 21, 16, 463289))
```

---

### Post-init Processing

- When `dataclasses.__post_init__()` is defined on the class, it will be called by the generated [`__init__()`](https://docs.python.org/3/reference/datamodel.html#object.__init__), normally as `self.__post_init__()`.
- Among other uses, this allows for initializing field values that depend on one or more other fields. 

---

### Post-init Processing

```python
from dataclasses import dataclass, field

@dataclass
class Student:
    name: str
    # Exclude is_antagonist from __init__
    is_antagonist: bool = field(init=False)
    
    def __post_init__(self):
        # Set is_antagonist based on the name
        self.is_antagonist = self.name.lower() == "bower"

for s in [Student("Mario"), Student("Bower")]:
    print(f"{s.name}: Antagonist? {s.is_antagonist}")
```

---

### Post-init Processing

- `__post_init__` runs only **ONCE** during object initialization. It does not automatically update to reflect subsequent changes to the object.

```
from dataclasses import dataclass, field

@dataclass
class Student:
    name: str
    is_antagonist: bool = field(init=False)
    
    def __post_init__(self):
        self.is_antagonist = self.name.lower() == "bower"

student = Student("Bower")
student.name = "Luigi"
print(f"{student.name}: Antagonist? {student.is_antagonist}")
```

---

### `@property` Decorator

- `@property` creates a computed property.

```python
from dataclasses import dataclass

@dataclass
class Rectangle:
    width: float
    height: float

    @property
    def area(self):
        return self.width * self.height

rect = Rectangle(width=2.0, height=3.0)
print(rect.area)  # 6.0
# Changing rect.width to 3.0 will result in an area of 9.0
```

---

### Inheritance with `dataclasses`

- The `dataclasses` module supports inheritance, allowing a data class to inherit attributes from another data class.

```python
from dataclasses import dataclass

@dataclass(order=True)
class Person():
    name: str
    email: str

@dataclass(order=True)
class Employee(Person):
    salary: int
    departament: str

print(Employee("Elon", "musk@x.com", 1_000_000, "Bossing"))
```

---

### Pydantic Validation

- Pydantic Data validation for Python:

  - Most widely used data validation library for Python

  - Enforces standard type annotation

  - Plays nicely with type checkers, IDEs and your brain

  - Fast and extensible

[Pydantic GitHub Repo](https://github.com/pydantic/pydantic), [Pydantic Doc](https://docs.pydantic.dev/)

---

### Pydantic Examples

```python
from datetime import datetime
from pydantic import BaseModel, PositiveInt

class User(BaseModel):
    id: int  
    name: str = 'John Doe'  
    signup_ts: datetime | None  
    tastes: dict[str, PositiveInt]  

external_data = {
    'id': 123, 'signup_ts': '2019-06-01 12:22',  
    'tastes': { 'wine': 9, b'cheese': 7, 'cabbage': '1', },
}

user = User(**external_data)
```

---

### Pydantic Models

- One of the primary ways of defining schema in Pydantic is via models. Models are simply classes which inherit from [`BaseModel`](https://docs.pydantic.dev/latest/api/base_model/#pydantic.BaseModel) and define fields as annotated attributes.
- Models share many similarities with Python's [dataclasses](https://docs.python.org/3/library/dataclasses.html#module-dataclasses), but have been designed with some subtle-yet-important differences that streamline certain workflows related to validation, serialization, and JSON schema generation.

---

### Pydantic Models

- Untrusted data can be passed to a model and, after parsing and validation, Pydantic guarantees that the fields of the resultant model instance will conform to the field types defined on the model.

```python
from pydantic import BaseModel, ConfigDict

class User(BaseModel):     # `User` is a model with two fields
    # `id` is an integer and is required
    id: int
    # `name` is a string and is not required
    name: str = 'Jane Doe' # `name` has a default value
    
    model_config = ConfigDict(str_max_length=10) 
```

---

### Pydantic Validation

- `user` is an instance of `User`. Initialization of the object will perform all parsing and validation. If no [`ValidationError`](https://docs.pydantic.dev/latest/api/pydantic_core/#pydantic_core.ValidationError) exception is raised, you know the resulting model instance is valid.

```python
from pydantic import BaseModel, ConfigDict

class User(BaseModel):
    id: int
    name: str = 'Jane Doe'
    
    model_config = ConfigDict(str_max_length=10)

user = User(id="one-two-three", name="Jane Doe")
print(user.model_dump())
# ValidationError: 1 validation error for User id
# Input should be a valid integer, unable to parse it as an integer
# [type=int_parsing, input_value='one-two-three', input_type=str]
```

---

### Pydantic Data Conversion

- Pydantic may cast input data to force it to conform to model field types, and in some cases this may result in a loss of information.

```python
from pydantic import BaseModel

class Model(BaseModel):
    a: int
    b: float
    c: str

print(Model(a=3.000, b='2.72', c=b'binary data').model_dump())
#> {'a': 3, 'b': 2.72, 'c': 'binary data'}
```

---

### Pydantic vs. Dataclasses

- Pydantic is a mighty workhorse, offering robust validation, data sanitization, type coercion nearly implicitly. The drawbacks here are a little bit increased memory consumption and learning curve.
- Python Dataclass is a neat, quick, and affordable approach for model build patterns, validation, and maintaining the source of truth as it should. The drawbacks here are the necessity of tweaking its structures to your needs, creating your own validators, or validation methods.

[Validators approach in Python - Pydantic vs. Dataclasses](https://codetain.com/blog/validators-approach-in-python-pydantic-vs-dataclasses/)

---

### Tuple Recap

- In Python, a **`tuple`** is a built-in data type that allows you to create **immutable sequences** of values.
- The values or items in a tuple can be of any type.

```python
# Accessing values by index in a regular tuple can be
# frustrating, hard to read, and error-prone. 
point = (2, 4)
print(point)
print(f"x: {point[0]}, y: {point[1]}")

point[0] = 100
# TypeError: 'tuple' object does not support item assignment
```

---

### `namedtuple` in Python

- Python’s [`namedtuple()`](https://docs.python.org/3/library/collections.html#collections.namedtuple) is a [factory function](https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)) that’s available in the [`collections`](https://docs.python.org/3/library/collections.html#module-collections) module.
- It allows you to create a [`tuple`](https://realpython.com/python-tuple/) [subclass](https://realpython.com/ref/glossary/subclass/) with **named fields**.
- `namedtuple` instances act like tuples but allow value access via field names and dot notation, which makes your code more readable and Pythonic.

---

### Creating a `namedtuple` Type

```python
from collections import namedtuple

# 1st parameter is typename, 2nd parameter is field names.
Point = namedtuple("Point", "x y")
point = Point(2, 4)

print(point)                           # Point(x=2, y=4)
print(f"x: {point.x}, y: {point.y}")   # x: 2, y: 4
print(f"x: {point[0]}, y: {point[1]}") # x: 2, y: 4

point.x = 100
# AttributeError: can't set attribute
point[0] = 100
# TypeError: 'Point' object does not support item assignment
```

---

### Creating a `namedtuple` Type

- You can use the [`._make()`](https://docs.python.org/3/library/collections.html#collections.somenamedtuple._make) method to create `namedtuple` instances from an iterable of values.

```python
from collections import namedtuple

Student = namedtuple("Student", "name age school")

# ._make() is a class method that works as an alternative
# class constructor. It returns a new namedtuple instance.
# ._make() expects a single iterable as an argument,
# such as a list in this example.
student = Student._make(["Mario", 20, "SADT"])
print(student) # Student(name='Mario', age=20, school='SADT')
```

---

#### Converting Named Tuples Into Dictionaries

- You can convert existing named tuples into dictionaries using [`._asdict()`](https://docs.python.org/3/library/collections.html#collections.somenamedtuple._asdict).
- This method returns a new dictionary that uses the field names as keys and the stored items as values.

```python
from collections import namedtuple

Student = namedtuple("Student", "name age school")
student = Student("Mario", 20, "SADT")

print(student._asdict())
# {'name': 'Mario', 'age': 20, 'school': 'SADT'}
```

---

#### `namedtuple` vs. Dictionaries

- In terms of readability, dictionaries are as readable as named tuples. Even though dictionaries don’t provide a way to access attributes using dot notation.
- A big difference between them is that dictionaries are [mutable](https://docs.python.org/3/glossary.html#term-mutable) and named tuples are immutable.
- Operations on named tuples are slightly faster than similar operations on dictionaries.

---

### `namedtuple` vs. Data Classes

- In terms of readability, there are no significant differences. Both provide similar string representations and allow attribute access using dot notation.
- Data Classes can be thought of as “mutable namedtuples with defaults.” [PEP 557](https://www.python.org/dev/peps/pep-0557/#abstract)
- If you set `frozen` to `True` in the call to `@dataclass`, then you make the data class immutable.

---

### `namedtuple` vs. Data Classes

- A subtle difference between named tuples and data classes is that the latter aren’t iterable by default.
- Regarding memory consumption, named tuples are more lightweight than data classes.
- The performance difference is minimal. Both data structures perform equivalently in attribute access operations.

---

### Key Takeaways - Data Classes

- Simplify class creation with the @dataclass decorator, automatically generating methods like `__init__`, `__repr__`, and `__eq__`.
- Reduce boilerplate code by defining fields with type hints, improving readability and maintainability.
- Support customization with parameters like `order`, `unsafe_hash` and `frozen` for flexible class behavior.

---

### Key Takeaways - Data Classes

- Provide default values, type checking, and post-initialization processing via `__post_init__` for robust data handling.
- Enable inheritance, allowing data classes to extend attributes and methods from other data classes.
- Ideal for classes primarily used to store data, offering a concise and Pythonic alternative to traditional classes.

---

### Key Takeaways - `namedtuple`

- Create and utilize namedtuple classes and instances.
- Leverage namedtuple features for enhanced functionality.
- Use namedtuple to write more Pythonic, readable code.
- Select namedtuple over other data structures when suitable.

---

### Sources:

- https://docs.python.org/3/library/dataclasses.html
- https://realpython.com/python-data-classes/
- https://realpython.com/python-repr-vs-str/
- https://realpython.com/python-namedtuple/
- https://www.python.org/dev/peps/pep-0557/#abstract
- https://docs.pydantic.dev/latest/